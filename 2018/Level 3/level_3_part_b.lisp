(defun parse-claim (claim)
  (let* ((parts (split-string claim))
         (claim-id (parse-integer (subseq (nth 0 parts) 1))) ; Skip the # character
         (left (parse-integer (nth 1 parts)))
         (top (parse-integer (nth 2 parts)))
         (width (parse-integer (nth 3 parts)))
         (height (parse-integer (nth 4 parts))))
    (list claim-id left top width height)))

(defun split-string (string)
  (let ((result '())
        (start 0)
        (delimiters '(#\Space #\@ #\: #\x #\,)))
    (loop for i from 0 to (length string)
          do (if (or (= i (length string))
                     (member (char string i) delimiters))
                 (progn
                   (when (/= start i)
                     (push (subseq string start i) result))
                   (setq start (1+ i)))))
    (nreverse result)))

(defun process-claims (filename)
  (let ((fabric (make-hash-table :test 'equal))
        (claims '()))
    (with-open-file (stream filename)
      (loop for line = (read-line stream nil)
            while line
            do (let ((claim (parse-claim line)))
                 (when claim
                   (let* ((claim-id (nth 0 claim))
                          (left (nth 1 claim))
                          (top (nth 2 claim))
                          (width (nth 3 claim))
                          (height (nth 4 claim)))
                     (push claim claims)
                     (dotimes (i width)
                       (dotimes (j height)
                         (let ((coordinate (list (+ left i) (+ top j))))
                           (let ((entries (gethash coordinate fabric '())))
                             (push (list claim-id coordinate) entries)
                             (setf (gethash coordinate fabric) entries)))))))))

    ;; Determine claims that overlap
    (let ((overlapping-claims (make-hash-table :test 'equal)))
      (maphash (lambda (key value)
                 (when (> (length value) 1)
                   (dolist (entry value)
                     (let ((claim-id (first entry)))
                       (push claim-id (gethash claim-id overlapping-claims '()))))))
               fabric)
      ;; Find the non-overlapping claim
      (dolist (claim claims)
        (let ((claim-id (nth 0 claim)))
          (unless (find claim-id (gethash claim-id overlapping-claims))
            (return-from process-claims claim-id))))))))

(let ((filename "input_level_3.txt"))
  (format t "ID of the only claim that doesn't overlap: ~d~%" (process-claims filename)))